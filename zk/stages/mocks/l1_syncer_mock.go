// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ledgerwatch/erigon/zk/stages (interfaces: IL1Syncer)
//
// Generated by this command:
//
//	mockgen -typed=true -destination=./mocks/l1_syncer_mock.go -package=mocks . IL1Syncer
//

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	types "github.com/ledgerwatch/erigon/core/types"
	gomock "go.uber.org/mock/gomock"
)

// MockIL1Syncer is a mock of IL1Syncer interface.
type MockIL1Syncer struct {
	ctrl     *gomock.Controller
	recorder *MockIL1SyncerMockRecorder
}

// MockIL1SyncerMockRecorder is the mock recorder for MockIL1Syncer.
type MockIL1SyncerMockRecorder struct {
	mock *MockIL1Syncer
}

// NewMockIL1Syncer creates a new mock instance.
func NewMockIL1Syncer(ctrl *gomock.Controller) *MockIL1Syncer {
	mock := &MockIL1Syncer{ctrl: ctrl}
	mock.recorder = &MockIL1SyncerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIL1Syncer) EXPECT() *MockIL1SyncerMockRecorder {
	return m.recorder
}

// CheckL1BlockFinalized mocks base method.
func (m *MockIL1Syncer) CheckL1BlockFinalized(arg0 uint64) (bool, uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckL1BlockFinalized", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CheckL1BlockFinalized indicates an expected call of CheckL1BlockFinalized.
func (mr *MockIL1SyncerMockRecorder) CheckL1BlockFinalized(arg0 any) *MockIL1SyncerCheckL1BlockFinalizedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckL1BlockFinalized", reflect.TypeOf((*MockIL1Syncer)(nil).CheckL1BlockFinalized), arg0)
	return &MockIL1SyncerCheckL1BlockFinalizedCall{Call: call}
}

// MockIL1SyncerCheckL1BlockFinalizedCall wrap *gomock.Call
type MockIL1SyncerCheckL1BlockFinalizedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIL1SyncerCheckL1BlockFinalizedCall) Return(arg0 bool, arg1 uint64, arg2 error) *MockIL1SyncerCheckL1BlockFinalizedCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIL1SyncerCheckL1BlockFinalizedCall) Do(f func(uint64) (bool, uint64, error)) *MockIL1SyncerCheckL1BlockFinalizedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIL1SyncerCheckL1BlockFinalizedCall) DoAndReturn(f func(uint64) (bool, uint64, error)) *MockIL1SyncerCheckL1BlockFinalizedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ConsumeQueryBlocks mocks base method.
func (m *MockIL1Syncer) ConsumeQueryBlocks() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ConsumeQueryBlocks")
}

// ConsumeQueryBlocks indicates an expected call of ConsumeQueryBlocks.
func (mr *MockIL1SyncerMockRecorder) ConsumeQueryBlocks() *MockIL1SyncerConsumeQueryBlocksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConsumeQueryBlocks", reflect.TypeOf((*MockIL1Syncer)(nil).ConsumeQueryBlocks))
	return &MockIL1SyncerConsumeQueryBlocksCall{Call: call}
}

// MockIL1SyncerConsumeQueryBlocksCall wrap *gomock.Call
type MockIL1SyncerConsumeQueryBlocksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIL1SyncerConsumeQueryBlocksCall) Return() *MockIL1SyncerConsumeQueryBlocksCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIL1SyncerConsumeQueryBlocksCall) Do(f func()) *MockIL1SyncerConsumeQueryBlocksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIL1SyncerConsumeQueryBlocksCall) DoAndReturn(f func()) *MockIL1SyncerConsumeQueryBlocksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlock mocks base method.
func (m *MockIL1Syncer) GetBlock(arg0 uint64) (*types.Block, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlock", arg0)
	ret0, _ := ret[0].(*types.Block)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlock indicates an expected call of GetBlock.
func (mr *MockIL1SyncerMockRecorder) GetBlock(arg0 any) *MockIL1SyncerGetBlockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlock", reflect.TypeOf((*MockIL1Syncer)(nil).GetBlock), arg0)
	return &MockIL1SyncerGetBlockCall{Call: call}
}

// MockIL1SyncerGetBlockCall wrap *gomock.Call
type MockIL1SyncerGetBlockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIL1SyncerGetBlockCall) Return(arg0 *types.Block, arg1 error) *MockIL1SyncerGetBlockCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIL1SyncerGetBlockCall) Do(f func(uint64) (*types.Block, error)) *MockIL1SyncerGetBlockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIL1SyncerGetBlockCall) DoAndReturn(f func(uint64) (*types.Block, error)) *MockIL1SyncerGetBlockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetHeader mocks base method.
func (m *MockIL1Syncer) GetHeader(arg0 uint64) (*types.Header, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetHeader", arg0)
	ret0, _ := ret[0].(*types.Header)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetHeader indicates an expected call of GetHeader.
func (mr *MockIL1SyncerMockRecorder) GetHeader(arg0 any) *MockIL1SyncerGetHeaderCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetHeader", reflect.TypeOf((*MockIL1Syncer)(nil).GetHeader), arg0)
	return &MockIL1SyncerGetHeaderCall{Call: call}
}

// MockIL1SyncerGetHeaderCall wrap *gomock.Call
type MockIL1SyncerGetHeaderCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIL1SyncerGetHeaderCall) Return(arg0 *types.Header, arg1 error) *MockIL1SyncerGetHeaderCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIL1SyncerGetHeaderCall) Do(f func(uint64) (*types.Header, error)) *MockIL1SyncerGetHeaderCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIL1SyncerGetHeaderCall) DoAndReturn(f func(uint64) (*types.Header, error)) *MockIL1SyncerGetHeaderCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLastCheckedL1Block mocks base method.
func (m *MockIL1Syncer) GetLastCheckedL1Block() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLastCheckedL1Block")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetLastCheckedL1Block indicates an expected call of GetLastCheckedL1Block.
func (mr *MockIL1SyncerMockRecorder) GetLastCheckedL1Block() *MockIL1SyncerGetLastCheckedL1BlockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLastCheckedL1Block", reflect.TypeOf((*MockIL1Syncer)(nil).GetLastCheckedL1Block))
	return &MockIL1SyncerGetLastCheckedL1BlockCall{Call: call}
}

// MockIL1SyncerGetLastCheckedL1BlockCall wrap *gomock.Call
type MockIL1SyncerGetLastCheckedL1BlockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIL1SyncerGetLastCheckedL1BlockCall) Return(arg0 uint64) *MockIL1SyncerGetLastCheckedL1BlockCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIL1SyncerGetLastCheckedL1BlockCall) Do(f func() uint64) *MockIL1SyncerGetLastCheckedL1BlockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIL1SyncerGetLastCheckedL1BlockCall) DoAndReturn(f func() uint64) *MockIL1SyncerGetLastCheckedL1BlockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLogsChan mocks base method.
func (m *MockIL1Syncer) GetLogsChan() chan []types.Log {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLogsChan")
	ret0, _ := ret[0].(chan []types.Log)
	return ret0
}

// GetLogsChan indicates an expected call of GetLogsChan.
func (mr *MockIL1SyncerMockRecorder) GetLogsChan() *MockIL1SyncerGetLogsChanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogsChan", reflect.TypeOf((*MockIL1Syncer)(nil).GetLogsChan))
	return &MockIL1SyncerGetLogsChanCall{Call: call}
}

// MockIL1SyncerGetLogsChanCall wrap *gomock.Call
type MockIL1SyncerGetLogsChanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIL1SyncerGetLogsChanCall) Return(arg0 chan []types.Log) *MockIL1SyncerGetLogsChanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIL1SyncerGetLogsChanCall) Do(f func() chan []types.Log) *MockIL1SyncerGetLogsChanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIL1SyncerGetLogsChanCall) DoAndReturn(f func() chan []types.Log) *MockIL1SyncerGetLogsChanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetProgressMessageChan mocks base method.
func (m *MockIL1Syncer) GetProgressMessageChan() chan string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetProgressMessageChan")
	ret0, _ := ret[0].(chan string)
	return ret0
}

// GetProgressMessageChan indicates an expected call of GetProgressMessageChan.
func (mr *MockIL1SyncerMockRecorder) GetProgressMessageChan() *MockIL1SyncerGetProgressMessageChanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProgressMessageChan", reflect.TypeOf((*MockIL1Syncer)(nil).GetProgressMessageChan))
	return &MockIL1SyncerGetProgressMessageChanCall{Call: call}
}

// MockIL1SyncerGetProgressMessageChanCall wrap *gomock.Call
type MockIL1SyncerGetProgressMessageChanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIL1SyncerGetProgressMessageChanCall) Return(arg0 chan string) *MockIL1SyncerGetProgressMessageChanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIL1SyncerGetProgressMessageChanCall) Do(f func() chan string) *MockIL1SyncerGetProgressMessageChanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIL1SyncerGetProgressMessageChanCall) DoAndReturn(f func() chan string) *MockIL1SyncerGetProgressMessageChanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsDownloading mocks base method.
func (m *MockIL1Syncer) IsDownloading() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDownloading")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsDownloading indicates an expected call of IsDownloading.
func (mr *MockIL1SyncerMockRecorder) IsDownloading() *MockIL1SyncerIsDownloadingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDownloading", reflect.TypeOf((*MockIL1Syncer)(nil).IsDownloading))
	return &MockIL1SyncerIsDownloadingCall{Call: call}
}

// MockIL1SyncerIsDownloadingCall wrap *gomock.Call
type MockIL1SyncerIsDownloadingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIL1SyncerIsDownloadingCall) Return(arg0 bool) *MockIL1SyncerIsDownloadingCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIL1SyncerIsDownloadingCall) Do(f func() bool) *MockIL1SyncerIsDownloadingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIL1SyncerIsDownloadingCall) DoAndReturn(f func() bool) *MockIL1SyncerIsDownloadingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsSyncStarted mocks base method.
func (m *MockIL1Syncer) IsSyncStarted() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsSyncStarted")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsSyncStarted indicates an expected call of IsSyncStarted.
func (mr *MockIL1SyncerMockRecorder) IsSyncStarted() *MockIL1SyncerIsSyncStartedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsSyncStarted", reflect.TypeOf((*MockIL1Syncer)(nil).IsSyncStarted))
	return &MockIL1SyncerIsSyncStartedCall{Call: call}
}

// MockIL1SyncerIsSyncStartedCall wrap *gomock.Call
type MockIL1SyncerIsSyncStartedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIL1SyncerIsSyncStartedCall) Return(arg0 bool) *MockIL1SyncerIsSyncStartedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIL1SyncerIsSyncStartedCall) Do(f func() bool) *MockIL1SyncerIsSyncStartedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIL1SyncerIsSyncStartedCall) DoAndReturn(f func() bool) *MockIL1SyncerIsSyncStartedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// L1QueryHeaders mocks base method.
func (m *MockIL1Syncer) L1QueryHeaders(arg0 []types.Log) (map[uint64]*types.Header, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "L1QueryHeaders", arg0)
	ret0, _ := ret[0].(map[uint64]*types.Header)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// L1QueryHeaders indicates an expected call of L1QueryHeaders.
func (mr *MockIL1SyncerMockRecorder) L1QueryHeaders(arg0 any) *MockIL1SyncerL1QueryHeadersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "L1QueryHeaders", reflect.TypeOf((*MockIL1Syncer)(nil).L1QueryHeaders), arg0)
	return &MockIL1SyncerL1QueryHeadersCall{Call: call}
}

// MockIL1SyncerL1QueryHeadersCall wrap *gomock.Call
type MockIL1SyncerL1QueryHeadersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIL1SyncerL1QueryHeadersCall) Return(arg0 map[uint64]*types.Header, arg1 error) *MockIL1SyncerL1QueryHeadersCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIL1SyncerL1QueryHeadersCall) Do(f func([]types.Log) (map[uint64]*types.Header, error)) *MockIL1SyncerL1QueryHeadersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIL1SyncerL1QueryHeadersCall) DoAndReturn(f func([]types.Log) (map[uint64]*types.Header, error)) *MockIL1SyncerL1QueryHeadersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RunQueryBlocks mocks base method.
func (m *MockIL1Syncer) RunQueryBlocks(arg0 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RunQueryBlocks", arg0)
}

// RunQueryBlocks indicates an expected call of RunQueryBlocks.
func (mr *MockIL1SyncerMockRecorder) RunQueryBlocks(arg0 any) *MockIL1SyncerRunQueryBlocksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunQueryBlocks", reflect.TypeOf((*MockIL1Syncer)(nil).RunQueryBlocks), arg0)
	return &MockIL1SyncerRunQueryBlocksCall{Call: call}
}

// MockIL1SyncerRunQueryBlocksCall wrap *gomock.Call
type MockIL1SyncerRunQueryBlocksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIL1SyncerRunQueryBlocksCall) Return() *MockIL1SyncerRunQueryBlocksCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIL1SyncerRunQueryBlocksCall) Do(f func(uint64)) *MockIL1SyncerRunQueryBlocksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIL1SyncerRunQueryBlocksCall) DoAndReturn(f func(uint64)) *MockIL1SyncerRunQueryBlocksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StopQueryBlocks mocks base method.
func (m *MockIL1Syncer) StopQueryBlocks() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "StopQueryBlocks")
}

// StopQueryBlocks indicates an expected call of StopQueryBlocks.
func (mr *MockIL1SyncerMockRecorder) StopQueryBlocks() *MockIL1SyncerStopQueryBlocksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopQueryBlocks", reflect.TypeOf((*MockIL1Syncer)(nil).StopQueryBlocks))
	return &MockIL1SyncerStopQueryBlocksCall{Call: call}
}

// MockIL1SyncerStopQueryBlocksCall wrap *gomock.Call
type MockIL1SyncerStopQueryBlocksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIL1SyncerStopQueryBlocksCall) Return() *MockIL1SyncerStopQueryBlocksCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIL1SyncerStopQueryBlocksCall) Do(f func()) *MockIL1SyncerStopQueryBlocksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIL1SyncerStopQueryBlocksCall) DoAndReturn(f func()) *MockIL1SyncerStopQueryBlocksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// WaitQueryBlocksToFinish mocks base method.
func (m *MockIL1Syncer) WaitQueryBlocksToFinish() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitQueryBlocksToFinish")
}

// WaitQueryBlocksToFinish indicates an expected call of WaitQueryBlocksToFinish.
func (mr *MockIL1SyncerMockRecorder) WaitQueryBlocksToFinish() *MockIL1SyncerWaitQueryBlocksToFinishCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitQueryBlocksToFinish", reflect.TypeOf((*MockIL1Syncer)(nil).WaitQueryBlocksToFinish))
	return &MockIL1SyncerWaitQueryBlocksToFinishCall{Call: call}
}

// MockIL1SyncerWaitQueryBlocksToFinishCall wrap *gomock.Call
type MockIL1SyncerWaitQueryBlocksToFinishCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIL1SyncerWaitQueryBlocksToFinishCall) Return() *MockIL1SyncerWaitQueryBlocksToFinishCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIL1SyncerWaitQueryBlocksToFinishCall) Do(f func()) *MockIL1SyncerWaitQueryBlocksToFinishCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIL1SyncerWaitQueryBlocksToFinishCall) DoAndReturn(f func()) *MockIL1SyncerWaitQueryBlocksToFinishCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
